<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Auto-Paint</title>
    <meta charset="utf-8" />
    <style type="text/css">
      html,
      body {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        background:#fff;
      }

      canvas {
        display: block;
      }

      .guiHolder {
        position: fixed;
        right: 10px;
        top: 10px;
        width: 120px;
        border: 2px solid #d3d3d3;
        background-color: #ffffffaa;
        padding: 8px;
        display: flex;
        z-index: 100;
        flex-direction: column;
      }

      .title {
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .label {
        color: #000;
        font-family: sans-serif;
        font-size: 12pt;
        margin-top: 10px;
        margin-bottom: 5px;
      }

      .slider {
        -webkit-appearance: none;
        width: 90%;
        height: 10px;
        border-radius: 5px;
        background: #ffffff;
        border: 1px solid black;
        outline: none;
        opacity: 0.7;
        -webkit-transition: 0.2s;
        transition: opacity 0.2s;
      }

      .slider:hover {
        opacity: 1;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 25px;
        height: 25px;
        border-radius: 12px;
        border: 1px solid #afffb7;
        background: MediumSeaGreen;
        cursor: pointer;
      }

      .slider::-moz-range-thumb {
        width: 25px;
        height: 25px;
        border-radius: 12px;
        border: 1px solid #afffb7;
        background: MediumSeaGreen;
        cursor: pointer;
      }

      .layerHolder {
        margin-top: 20px;
      }

      #progressBar {
        display: none;
      }

      .buttonHolder {
        display: flex;
        overflow: hidden;
        flex-wrap: wrap;
        justify-content: center;
      }

      .button {
        border-radius: 10px;
        height: 30px;
        padding: 2px 6px;
        font-size: 14px;
        background-color: mediumseagreen;
        color: white;
        border: 1px solid #afffb7;
        margin: 2px 2px 0px 2px;
      }

      .button.reset {
        background-color: #ff6666;
      }

      .textarea {
        font-size: 10px;
        font-family: monospace;
        margin-bottom: 20px;
      }

      .checkbox {
        margin: 0.2em;
        border-radius: 5px;
      }

      .checkbox label {
        display: block;
        cursor: pointer;
      }

      .checkbox input[type="checkbox"] {
        display: none;
      }

      .checkbox input[type="checkbox"] + span:before {
        font-size: 18px;
        content: "\2714";
        border: 0.1em solid #000;
        border-radius: 0.2em;
        background-color: white;
        display: inline-block;
        width: 1em;
        height: 1em;
        padding-left: 0.2em;
        padding-bottom: 0.3em;
        margin-right: 0.2em;
        vertical-align: bottom;
        color: transparent;
        transition: 0.2s;
      }

      .checkbox input[type="checkbox"]:active + span:before {
        transform: scale(0);
      }

      .checkbox input[type="checkbox"]:checked + span:before {
        background-color: MediumSeaGreen;
        border-color: MediumSeaGreen;
        color: #fff;
      }

      .checkbox input[type="checkbox"]:disabled + span:before {
        transform: scale(1);
        border-color: #aaa;
      }

      .checkbox input[type="checkbox"]:checked:disabled + span:before {
        transform: scale(1);
        background-color: #bfb;
        border-color: #bfb;
      }

      .checkbox span {
        font-size: 14px;
        line-height: 25px;
      }

      .select {
        display: inline-block;
        position: relative;
        font-size: 14px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #fff;
        padding: 0.5em 1em;
        transition: border-color 0.2s, box-shadow 0.2s;
        width: 100%;
        margin-bottom: 5px;
      }

      .select:hover {
        border-color: #888;
      }

      .select:focus {
        border-color: MediumSeaGreen;
        box-shadow: 0 0 5px rgba(60, 179, 113, 0.5);
        outline: none;
      }

      .select option {
        padding: 0.5em;
        background-color: #fff;
      }

      .select option:hover {
        background-color: #f0f0f0;
      }

      .select option:checked {
        background-color: MediumSeaGreen;
        color: #fff;
      }

      .radio label {
        display: flex;
        width: 100%;
        margin-bottom: 5px;
      }

      .radio input[type="radio"] {
        width: 20px;
        height: 20px;
        accent-color: MediumSeaGreen;
        color: white;
        background-color: white;
      }

      .radio span {
        font-size: 14px;
        padding-top: 5px;
        line-height: 14px;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/gh/processing/p5.js-sound/lib/p5.sound.min.js"
    ></script>
    <script type="text/javascript" src="https://unpkg.com/hydra-synth"></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/gh/ffd8/hy5@main/hy5.js"
    ></script>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/@jaames/iro@5"
    ></script>
    <script type="text/javascript">
      let credits = { 
        names : [ 
          'michael.perret' 
        ] 
        ,class : 'IDCE SW24' 
        ,description : `Auto-Paint paints for you. Press to create a shape, press longer to make it bigger and send it in some direction.
        Press the Balls! button to create a bunch of random balls with random lifetimes and gravities. 
        Paint on different layers and apply custom hydra-effects per layer.
        The reactive checkbox will make the balls react to the audio input a bit :-)
        ` 
      } 

      const BallStatus = {
        BUILDING: 0,
        ACTIVE: 1,
        DEAD: 2,
      };

      const Forms = {
        circle: "Ball",
        square: "Square",
        line: "Line",
      };

      class Ball {
        constructor(
          x,
          y,
          px,
          py,
          vx,
          vy,
          color,
          size,
          opacity,
          rotation,
          gravity,
          liveTime,
          layer,
          form
        ) {
          this.x = x;
          this.y = y;
          this.px = px;
          this.py = py;
          this.vx = vx;
          this.vy = vy;
          this.color = color;
          this.size = size;
          this.opacity = opacity;
          this.rotation = rotation;
          this.gravity = gravity;
          this.liveTime = liveTime;
          this.layer = layer;
          this.status = BallStatus.BUILDING;
          this.show = true;
          this.created = Date.now();
          this.form = form ?? Forms.circle;
        }

        doPhysics() {
          if (
            !this.px ||
            (this.form === Forms.line &&
              // check if the position changed enough to warrant a line to be drawed
              Math.abs(this.px - this.x) > 1) ||
            Math.abs(this.py - this.y) > 1
          ) {
            this.px = this.x;
            this.py = this.y;
          }

          let collision = false;
          if (this.x + this.size / 2 >= canvas.width) {
            //condition: crossing right side
            this.vx = -this.vx * damping;
            this.x = canvas.width - this.size / 2;
            collision = true;
          } else if (this.x - this.size / 2 <= 0) {
            //condition: crossing left side
            this.vx = -this.vx * damping;
            this.x = this.size / 2;
            collision = true;
          } else if (this.y + this.size / 2 >= canvas.height) {
            //condition: touching bottom
            this.vy = -this.vy * damping;
            this.y = canvas.height - this.size / 2;

            //ensures ball rolls to a smooth stop
            if (this.gravity > 0) {
              this.vx *= friction;
            }
            collision = true;
          } else if (this.y - this.size / 2 <= 0) {
            //condition: touching top
            this.vy = -this.vy * damping;
            this.y = this.size / 2;

            //ensures ball rolls to a smooth stop
            if (this.gravity < 0) {
              this.vx *= friction;
            }

            collision = true;
          }

          //constant gravitational force
          this.vy += this.gravity;

          let ageInSeconds = (Date.now() - this.created) / 1000;
          if (ageInSeconds > this.liveTime) {
            this.opacity = this.opacity - 10;
          }

          //updating ball position
          this.x += this.vx;
          this.y += this.vy;

          return collision;
        }

        draw(ampIn) {
          if (this.layer) {
            let ampInfluence = Math.max(map(ampIn, 0, 100, 0, 10), 1);

            let c = color(
              this.color[0],
              this.color[1],
              this.color[2],
              this.opacity
            );
            this.layer.strokeWeight(0);
            this.layer.stroke(c);
            this.layer.fill(c);

            switch (this.form) {
              case Forms.circle:
                this.layer.circle(this.x, this.y, this.size * ampInfluence);
                break;
              case Forms.square:
                this.layer.rect(
                  this.x,
                  this.y,
                  this.size,
                  this.size * ampInfluence
                );
                break;
              case Forms.line:
                if (this.px && this.py) {
                  this.layer.strokeWeight(this.size);
                  this.layer.line(
                    this.px,
                    this.py,
                    this.x,
                    this.y * ampInfluence
                  );
                }
                break;
            }
          }
        }
      }
    </script>
    <script type="text/javascript">
      let layers = [];
      let selectedLayer = 0;
      let currentLayer;
      let orbitControlActive = false;
      let layerHolder;
      let initialSize = 10;
      let initialColor = [60, 179, 113];
      let initialLifeTime = 10;
      let initialGravity = 0;
      let initialForm = Forms.line;
      let audioReactive = false;

      let layerEffects = [
        `src(s0)`,
        `src(s1).modulate(voronoi(),0.1)`,
        `src(s2).modulate(noize(),0.01)`,
        `src(s3).diff(src(o2),1)`,
      ];

      let numberOfBalls = 1;
      // add layers for each ball

      let balls = [];
      let disturbance = false;
      let disturbanceColor = [0, 0, 0];
      let timeoutFunction;

      function updateHydra() {
        try {
          eval(layerEffects[0] + ".out(o0)");
        } catch (e) {
          console.error("s0 error: " + e);
          src(s0).out(o0);
        }

        try {
          eval(layerEffects[1] + ".out(o1)");
        } catch (e) {
          console.error("s1 error: " + e);
          src(s1).out(o1);
        }

        try {
          eval(layerEffects[2] + ".out(o2)");
        } catch (e) {
          console.error("s2 error: " + e);
          src(s2).out(o2);
        }

        try {
          eval(layerEffects[3] + ".out(o3)");
        } catch (e) {
          console.error("s3 error: " + e);
          src(s3).out(o3);
        }
      }

      // sandbox - start
      H.pixelDensity(2);

      updateHydra();
      render();

      P5.toggle(1);
      H.toggle(0);

      // sandbox - end

      //user editable variables, affect ball
      let damping = 0.9, //default is 0.9
        friction = 0.8; //default is 0.8

      let drawPath = false;

      function setup() {
        angleMode(DEGREES);
        pixelDensity(1);
        frameRate(60);
        createCanvas(windowWidth, windowHeight, WEBGL);
        drawGui();
        imageMode(CORNER);
        reset();
        setupAudio();
        background(255);
      }

      function draw() {
        clear();
        updateAudio();
        noStroke();

        // let anyDisturbance = false
        // let lastDisturbanceColor = [0, 0, 0]
        for (let b of balls) {
          if (b.status !== BallStatus.DEAD && b.opacity > 0) {
            b.doPhysics();
            if (b.layer) {
              b.draw(audioReactive ? ampEase : 1);
            }
          } else {
            // balls.delete(b)
          }
        }

        /*
  let i = 0;
  for (let l of layers) {
    if (l) {
      i++;
      push();
      texture(l);
      translate(0, 0, i * 10);
      rect(-width / 2, -height / 2, width, height);
      pop();
    }
  }*/

        push();
        texture(H.get(o0));
        translate(0, 0, 0);
        rect(-width / 2, -height / 2, width, height);
        pop();

        push();
        texture(H.get(o1));
        translate(0, 0, 1);
        rect(-width / 2, -height / 2, width, height);
        pop();

        push();
        texture(H.get(o2));
        translate(0, 0, 2);
        rect(-width / 2, -height / 2, width, height);
        pop();

        push();
        texture(H.get(o3));
        translate(0, 0, 3);
        rect(-width / 2, -height / 2, width, height);
        pop();

        /*
	if (!disturbance && anyDisturbance) {
		disturbance = true
		disturbanceColor = lastDisturbanceColor
		setTimeout(function() {
			console.log("timeout")
			disturbance = false;
			disturbanceColor = [0, 0, 0]
		},100)
	}
	*/
      }

      function reset() {
        balls = [];
        layers = [];
        addLayers();
      }

      function randomBalls() {
        for (let i = 0; i < 20; i++) {
          let randomX = random(10, width);
          let randomY = random(10, height);
          balls.push(
            new Ball(
              randomX,
              randomY,
              randomX,
              randomX,
              random(5, 20) * -random(1),
              random(5, 20) * -random(1),
              [random(255), random(255), random(255)],
              random(5, 50),
              255,
              0,
              random(-1, 1),
              random(5, 60),
              currentLayer,
              initialForm
            )
          );
        }
      }

      function keyPressed() {
        if (keyCode === ENTER) {
          reset();
        }
      }

      function mousePressed() {
        let ghpos = guiHolder.position();
        let ghsize = guiHolder.size();
        let border = 25;
        if (
          !(
            mouseX <= ghpos.x - border ||
            mouseX >= ghpos.x + ghsize.width + border ||
            mouseY <= ghpos.y - border ||
            mouseY >= ghpos.y + ghsize.height + border
          )
        ) {
          return;
        }

        if (orbitControlActive) return;
        balls.push(
          new Ball(
            mouseX,
            mouseY,
            mouseX,
            mouseY,
            0,
            0,
            initialColor,
            0,
            255,
            0,
            initialGravity,
            initialLifeTime,
            currentLayer,
            initialForm
          )
        );
      }

      function mouseDragged() {
        let ghpos = guiHolder.position();
        let ghsize = guiHolder.size();
        let border = 25;
        if (
          !(
            mouseX <= ghpos.x - border ||
            mouseX >= ghpos.x + ghsize.width + border ||
            mouseY <= ghpos.y - border ||
            mouseY >= ghpos.y + ghsize.height + border
          )
        ) {
          return;
        }

        if (orbitControlActive) return;
        lastBall = balls[balls.length - 1];
        if (lastBall.status === BallStatus.BUILDING) {
          lastBall.vx = (mouseX - lastBall.x) * 0.3;
          lastBall.vy = (mouseY - lastBall.y) * 0.3;
          lastBall.size = lastBall.size + 1;
          if (lastBall.size > width / 2) {
            lastBall.status = BallStatus.DEAD;
          }
        }
      }

      function mouseReleased() {
        if (orbitControlActive) return;
        lastBall = balls[balls.length - 1];
        if (lastBall) {
          lastBall.status = BallStatus.ACTIVE;
        }
      }

      function drawGui() {
        guiHolder = createDiv("").class("guiHolder");
        createDiv("Auto-Paint")
          .parent(guiHolder)
          .class("title")
          .draggable(guiHolder);

        let select = createSelect("Form");
        select.parent(guiHolder);
        select.class("select");
        select.input(function () {
          initialForm = this.value();
        });
        select.option(Forms.circle);
        select.option(Forms.square);
        select.option(Forms.line);

        select.selected(Forms.line);

        /*
  createDiv("Size").parent(guiHolder).class("label")

  createSlider(1, 100, initialSize, 1)
    .parent(guiHolder)
    .class("slider")
    .input(function () {
      initialSize = this.value()
    })
  */

        createDiv("").id("defaultPicker").parent(guiHolder);
        let defaultPicker = new iro.ColorPicker("#defaultPicker", {
          color: "#3cb371",
          width: 110,
          borderWidth: 1,
        });
        defaultPicker.on("color:change", function (color) {
          initialColor = [color.rgb.r, color.rgb.g, color.rgb.b];
        });

        createDiv("Lifetime").parent(guiHolder).class("label");

        createSlider(1, 30, initialLifeTime, 1)
          .parent(guiHolder)
          .class("slider")
          .input(function () {
            initialLifeTime = this.value();
          });

        createDiv("Gravity").parent(guiHolder).class("label");

        createSlider(-1, 1, initialGravity, 0.1)
          .parent(guiHolder)
          .class("slider")
          .input(function () {
            initialGravity = this.value();
          });

        let layerHolder = createDiv().parent(guiHolder).class("layerHolder");

        let radio = createRadio("Layer " + layers.length, true)
          .parent(layerHolder)
          .class("radio");

        radio.option("0", "Layer 1");
        radio.option("1", "Layer 2");
        radio.option("2", "Layer 3");
        radio.option("3", "Layer 4");

        radio.selected("0");

        radio.input(function () {
          selectedLayer = parseInt(this.value());
          currentLayer = layers[selectedLayer];
          document.getElementById("layerEffect").value =
            layerEffects[selectedLayer];
        });

        createInput("", "text")
          .value(layerEffects[0])
          .id("layerEffect")
          .parent(guiHolder)
          .class("textarea")
          .input(function () {
            layerEffects[selectedLayer] = this.value();
            updateHydra();
          });

        createCheckbox("Reactive", audioReactive)
          .parent(guiHolder)
          .class("checkbox")
          .input(function () {
            if (this.checked()) {
              audioReactive = true;
            } else {
              audioReactive = false;
            }
          });

        let buttonHolder = createDiv().parent(guiHolder).class("buttonHolder");

        createButton("Balls!")
          .parent(buttonHolder)
          .class("button")
          .mousePressed(function () {
            randomBalls();
          });

        createButton("Reset")
          .parent(buttonHolder)
          .class("button reset")
          .mousePressed(function () {
            reset();
          });

        createButton("Save")
          .parent(buttonHolder)
          .class("button")
          .mousePressed(function () {
            saveCanvas(`auto-paint-${new Date().toJSON().slice(0, 10)}`, "png");
          });

        createButton("GIF")
          .parent(buttonHolder)
          .class("button")
          .mousePressed(function () {
            saveGif(`auto-paint-${new Date().toJSON().slice(0, 10)}`, 5);
          });

        /*
  createCheckbox("Orbit", orbitControlActive)
    .parent(guiHolder)
    .class("checkbox")
    .input(function () {
      if (this.value()) {
        orbitControlActive = true;
      } else {
        orbitControlActive = false;
      }
    });
	*/
      }

      function addLayers() {
        for (let i = 0; i < 4; i++) {
          let layer = createGraphics(width, height);
          layers.push(layer);
        }

        currentLayer = layers[0];

        s0.initP5(layers[0]);
        s1.initP5(layers[1]);
        s2.initP5(layers[2]);
        s3.initP5(layers[3]);
      }

      document.querySelectorAll(".guiHolder").forEach((element) => {
        element.addEventListener("touchstart", (event) => {
          event.stopPropagation();
          console.log("UI element touched");
        });
      });

      /* AUDIO INIT */
      let mic,
        fftRaw,
        fft = [],
        waveform = [],
        amp = 0.0,
        ampStereo = {
          l: 0.0,
          r: 0.0,
        },
        ampEase = 0.0,
        numBins = 512,
        bands = 12;

      function setupAudio() {
        userStartAudio();
        mic = new p5.AudioIn();
        mic.start();
        fftRaw = new p5.FFT(0.75, numBins);
        fftRaw.setInput(mic);
      }

      function updateAudio() {
        fftRaw.analyze();
        amp = mic.getLevel() * 1000; // average mixed amplitude
        ampStereo.l = mic.amplitude.getLevel(0) * 500; // average left amplitude
        ampStereo.r = mic.amplitude.getLevel(1) * 500; // average right amplitude
        ampEase = ease(amp, ampEase, 0.075); // smooth 'amp'
        waveform = fftRaw.waveform(); // array (-1, 1)
        fft = fftRaw.logAverages(fftRaw.getOctaveBands(bands)); // array (0, 255)
      }

      // custom ease function
      function ease(iVal, oVal, eVal) {
        return (oVal += (iVal - oVal) * eVal);
      }

    </script>
  </body>
</html>
