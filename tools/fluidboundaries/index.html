<!DOCTYPE html>
<html>
<head>
	<title>fluidboundaries_002</title>
	<meta charset="utf-8">
	<!-- Compiled w/ P5LIVE, http://github.com/ffd8/p5live -->
	<style type="text/css">
		body{
			margin:0;
			overflow:hidden;
		}
		canvas{
			position:fixed;
			top:0;
			left:0;
			z-index:-1;
			width:100vw;
			height:100vh;
			margin:0;
		}
	</style>
	<script type="text/javascript">
		// eco-mode = only render if window focused
		window.onblur = function () {
			noLoop();
		};
		window.onfocus = function () {
			loop();
		};
	</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/processing/p5.js-sound/lib/p5.sound.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/hydra-synth"></script>
</head>
<body style="background:rgb(0, 0, 0);">

<script type="text/javascript">
//fluidboundaries_002

/* CUSTOM FUNCTIONS FOR P5LIVE */
// keep fullscreen if window resized
function windowResized() {
	resizeCanvas(windowWidth, windowHeight);
}

// custom ease function
function ease(iVal, oVal, eVal){
	return oVal += (iVal - oVal) * eVal;
}

// processing compatibility
function println(msg){
	print(msg);
}


var credits = { 
	names : [ 
		'Fabienne.Stoll'  
	] 
	,class : 'IDCE SW24' 
	,description : `Imagine a world with fluid boundaries. A society where social norms liquify. Where colors, shapes, sizes and cultures blend and blur. What if we reconnect our body to our brains to deal with our unconscious biases? What if our barriers were more porous? Letâ€™s design that world together. Starting with you..` 
} 

let font
let fSize // font size
let msg // text to write
let pts = [] // store path data

let mySelect, fluidMode; // global var for select + drawing mode 
let opts = ['liquid', 'bubbles', 'ripples', 'waves'] // array of options 

let libs = ['https://unpkg.com/hydra-synth', 'includes/libs/hydra-synth.js']
let hydra = new Hydra()
var myRes = 2
hydra.setResolution(window.innerWidth * 2, window.innerHeight * 2) // retina res
hydra.canvas.style.zIndex = -1

// sandbox - start
s0.initCam()

//liquid
osc()
	.blend(noise(), 0.3)
	.modulate(noise().luma(0, 9, 0.1), .20)
	.color(1, 0, 9)
	.modulateRotate(src(s0).mask(shape(100, 0.25, 0.5)).scale(1, 1, 1.25))
	.out(o0)

//bubbles
osc(4, 0.1, 0.8)
	.color(1, 0.6, 1)
	.rotate(0.30, 0.01)
	.pixelate(5, 40)
	.modulate(noise(2), () => 1.5 * Math.sin(0.1 * time))
	.modulateRotate(src(s0).mask(shape(100, 0.25, 0.5)).scale(1, 1, 1.25))
	.out(o1)

//ripples
osc(3, 0.01, 0.4)
	.color(3, 1.2, 1.3)
	.saturate(1.4)
	.modulateRepeat(osc(2), 1, 2, 4, 3)
	.modulateKaleid(osc(12, 0.05, 0), 1)
	.luma(0.8)
	.rotate(0.45, 0.1, 255)
	.scale(1)
	.modulateRotate(src(s0).mask(shape(100, 0.25, 0.5)).scale(1, 1, 1.25))
	.out(o2)

//waves
osc(3.985, 0.172, 3)
	.color(0, 3, 8)
	.pixelate(14, 10)
	.rotate(2, 0.1)
	.mult(osc())
	.modulate(src(s0).scale(1, 1, 1.25))
	.out(o3)


render(o0)

// sandbox - stop

function preload() {
	// preload OTF font file
	font = loadFont('data/fonts/Lastoll_font-Regular.otf')
}

function setup() {
	createCanvas(windowWidth, windowHeight, WEBGL)

//textTopoint surprise start
	fSize = 400
		textFont(font)
		textSize(fSize)
		msg = 'BOUNCE'
		// pts = font.textToPoints(msg, 0, 10, fSize, {
		// 	sampleFactor: 0.1, // increase for more points
		// 	simplifyThreshold: 0.0 // increase to remove collinear points
		// })
		//console.log(pts) // { x, y, path angle }
		genType(msg, fSize)
		stroke(255)
		strokeWeight(2)
		noFill();
//textTopoint surprise stop

	//GUI start
	guiHolder = createDiv('').class('guiHolder')

	createDiv('LIQUEFIYING BOUNDARIES').parent(guiHolder).class('guiBar').draggable(guiHolder)

	//createDiv('background').parent(guiHolder).class('guiLabel')
	//sliderBackground = createSlider(0, 255, 0).parent(guiHolder).class('guiSlider')

	//Dropdown
	createDiv('WHAT IF BOUNDARIES WERE FLUID?').parent(guiHolder).class('guiTitel')

	createDiv('Fluidize me').parent(guiHolder).class('guiLabel')
	mySelect = createSelect().parent(guiHolder)

	// cycle array to add options 
	for(let o of opts) {
		mySelect.option(o)
	}

	// init with random option 
	fluidMode = random(opts)
	mySelect.selected(fluidMode);

	// set drawMode var on change 
	mySelect.changed(function() {
		fluidMode = this.value()
		if(fluidMode == 'liquid') {
			eval('render(o0)')
		} else if(fluidMode == 'bubbles') {
			eval('render(o1)')
		} else if(fluidMode == 'ripples') {
			eval('render(o2)')
		} else if(fluidMode == 'waves') {
			eval('render(o3)')
		}
	});

	createElement('br').parent(guiHolder) // break
	createElement('br').parent(guiHolder) // break

	createDiv('Surprise me').parent(guiHolder).class('guiLabel')
	Surprise1 = createCheckbox('', false).parent(guiHolder)
	createDiv('Surprise me again').parent(guiHolder).class('guiLabel')
	Surprise2 = createCheckbox('', false).parent(guiHolder)

	createElement('br').parent(guiHolder) // break
	createElement('br').parent(guiHolder) // break

	createButton('Export as PNG').parent(guiHolder).class('guiButton').mouseClicked(function() {
		// save('fluidMe.png') // export p5 as png
		hydra.synth.screencap() // export hydra as png
		// saveGif('luidMe.gif', 1) // export gif: name, xSeconds
	})


	createElement('style', `
        .guiHolder{
            position:fixed;
            right:20px;
            top:20px;
            width:250px;
            height:270px;
            background-color: rgba(0,0,0,.5);
            font-family:monospace;
            padding:5px;
           ;
        }
        .guiBar{
            background-color: #333333;
            color:white;
            text-align:left;
            padding:5px;
        }
        .guiTitel{
            color:#fff;
            padding:5px;
        }
        .guiLabel{
            color:#fff;
            padding:5px;
        }
        .guiSlider{
            width:95%;
        }
        .guiButton{
            clear:both;
        }
    `)
	//GUI stop
}

function draw() {
	//background(0);
	clear()

	if(Surprise1.checked()) {
		//background(0)
		clear()
		const d = 10 + sin(frameCount / 50) * 50
		const angle = frameCount / 200
		push()
	//	translate(60, height * 5 / 8)
		for(let i = 0; i < pts.length; i++) {
			const p = pts[i]
			push()
			translate(p.x, p.y)
			rotate(angle)
			line(-d, -d, +d, +d)
			pop()
		}
		pop()

	} else {
		fluidMode = random(opts)
	}

	if(Surprise2.checked()) {
	textAlign(CENTER, CENTER)
		textSize(200);
		fill('yellow');
		text('stand up', -400, 220);
		fill('cornflowerblue');
		text('AND BOUNCE', frameCount%width/2, frameCount%height/2);
	} else {
		fluidMode = random(opts)
	}
}

//BoxforTextToPoint start
function genType(txtString, txtSize) {
	// grab bounding box of text
	let bounds = font.textBounds(txtString, 0, 0, txtSize)

	// textToPoints(txt, x, y, size, options)
	pts = font.textToPoints(txtString, -bounds.w / 2, bounds.h / 2, txtSize, {
		sampleFactor: .07,
		simplifyThreshold: 0
	})
	//BoxforTextToPoint stop
}
</script>

</body>
</html>